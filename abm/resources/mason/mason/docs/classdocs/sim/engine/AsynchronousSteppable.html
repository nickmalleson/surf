<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_72) on Wed Apr 27 17:13:49 BST 2016 -->
<title>AsynchronousSteppable</title>
<meta name="date" content="2016-04-27">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="AsynchronousSteppable";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":42,"i4":10,"i5":42,"i6":10,"i7":10,"i8":10,"i9":42};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"],32:["t6","Deprecated Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../sim/engine/MakesSimState.html" title="interface in sim.engine"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sim/engine/AsynchronousSteppable.html" target="_top">Frames</a></li>
<li><a href="AsynchronousSteppable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">sim.engine</div>
<h2 title="Class AsynchronousSteppable" class="title">Class AsynchronousSteppable</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>sim.engine.AsynchronousSteppable</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd>java.io.Serializable, <a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">AsynchronousSteppable</span>
extends java.lang.Object
implements <a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></pre>
<div class="block">Fires up a separate thread which runs until the simulation model requests it be halted.
    This mechanism makes possible parallel threads which run in the background independently
    of the schedule being stepped.  Note that the use of such threads makes the simulation
    unable to guarantee replicability.
    
    <p>Like all multithreaded stuff, AsynchronousSteppables are inherently dangerous and not to be trifled with: they
    access data at the same time as other threads, and so must deal with locking.  In general
    if you lock on the Schedule, you are guaranteed atomic access to the underlying simulation
    model.  You'll need to do this for even basic things such as accessing the random number
    generator.  Locking on the Schedule is fairly course-grained, however: the simulation model
    obtains a lock on the Schedule for the whole duration of a Schedule's step.  Instead you
    might create your own lock shared between the AsynchronousSteppable and the main thread which
    allows access to some piece of data you both need in a more fine-grained fashion.  In this case,
    make certain that the GUI isn't trying to read that data (to display it, say), or that the GUI
    obtains a lock when it needs to as well.  If you have no idea what we're talking about:
    don't use an AsynchronousSteppable.
    
    <p>When an AsynchronousSteppable is stepped, it fires off a thread which performs the asynchronous
    task.  This task could be an infinite loop (or otherwise very long process) 
    or it could be a short one-shot thing which runs and ends.
    Infinite loops can be paused and resumed (for checkpointing) and they can be stopped entirely.
    
    <p>AsynchronousSteppables automatically register themselves to be stopped at the end of the simulation
    (and when stopped, they unregister themselves).  They're also paused and upaused for checkpoints.
    But if the task is an infinite loop, it's possible you may wish to stop the loop before the simulation
    ends, perhaps at an agreed-upon point in the schedule.  The easiest way to do this is to post a steppable
    on the Schedule which stops the AsynchronousSteppable, like this:
        
    <pre><tt>
   final AsynchronousSteppable s = ...
   Steppable stopper = new Steppable() { public void step(SimState state) { s.stop(); } } 
   schedule.scheduleOnce(s....);
   schedule.scheduleOnce(stopper....);
    </tt></pre>

    <p>If the task is a SHORT, one-shot process and the user can reasonably wait for the task to complete 
    after he has presed the 'stop' button, then run(false) should perform the asynchronous task, 
    run(true) should be set to do nothing, and halt(true) and halt(false) should both do nothing.
    Here's some code to show how to form such a beast.

    <pre><tt>
   AsynchronousSteppable s = new AsynchronousSteppable()
       {
       protected void run(boolean resuming, boolean restoringFromCheckpoint)
           {
           if (!resuming)
               {
               // do your stuff here
               }
           }
       };
    </tt></pre>
    
    <p>If the task is an infinite loop or otherwise long process, 
    it needs to be pausable, resumable, and haltable.  In this case,
    run(false) should perform the asynchronous task, halt(false) and halt(true) should both cause the thread
    to die or trigger events which will soon lead to thread death halt(...) returns, and run(true) should
    fire up the task loop again after it had been halted with halt(true).  The most common situation is where
    you don't distinguish between your thread being killed temporarily or being killed permanently,
    nor between starting and resuming.  Here's some code for this situation:
    
    <pre><tt>
   AsynchronousSteppable s = new AsynchronousSteppable()
       {
       boolean shouldQuit = false;
       Object[] lock = new Object[0]; // an array is a unique, serializable object

       protected void run(boolean resuming, boolean restoringFromCheckpoint)
           {
           boolean quit = false;
           
           while(!quit)
               {
               // do your stuff here -- assuming it doesn't block...
               
               synchronized(lock) { quit = shouldQuit; shouldQuit = false; }
               }
           // we're quitting -- do cleanup here if you need to
           }

       protected void halt(boolean pausing)
           {
           synchronized(lock) { shouldQuit = val; }
           }
       };
    </tt></pre>

    <p>It's possible you may need to distinguish between being started or being restarted (but pausing
    and quitting are considered the same).  For example, if you were writing to a log and needed to know
    whether to open the log fresh or to append to it.  You could do something along these lines:

    <pre><tt>
   AsynchronousSteppable s = new AsynchronousSteppable()
       {
       boolean shouldQuit = false;
       Object[] lock = new Object[0]; // an array is a unique, serializable object

       protected void run(boolean resuming, boolean restoringFromCheckpoint)
           {
           boolean quit = false;
           
           if (!resuming)
               {
               // we're starting fresh -- set up here if you have to
               }
           else
               {
               // we're resuming from a pause -- re-set up here if you have to
               }

           while(!quit)
               {
               // do your stuff here -- assuming it doesn't block...
               
               synchronized(lock) { quit = shouldQuit; shouldQuit = false; }
               }
           // we're quitting -- do cleanup here if you need to
           }

       protected void halt(boolean pausing)
           {
           synchronized(lock) { shouldQuit = val; }
           }
       };
    </tt></pre>

    <p>Further, it's possible you may need to distinguish between being started or being restarted (but pausing
    and quitting are considered the same), and additionally you need to know if you're being restarted after
    the simulation has been restored from a checkpoint.  For example, if you were writing to a log and needed to know
    whether to open the log fresh or to append to it; and if you're restoring from a an earlier checkpoint, you need
    to seek in the file to append in the right spot.  You could do something along these lines:

    <pre><tt>
   AsynchronousSteppable s = new AsynchronousSteppable()
       {
       boolean shouldQuit = false;
       Object[] lock = new Object[0]; // an array is a unique, serializable object

       protected void run(boolean resuming, boolean restoringFromCheckpoint)
           {
           boolean quit = false;
           
           if (!resuming)
               {
               // we're starting fresh -- set up here if you have to
               }
           else if (restoringFromCheckpoint)
               {
               // do anything you need when restoring from a checkpoint, like seeking in files
               }
           else
               {
               // we're resuming from a pause -- re-set up here if you have to
               }

           while(!quit)
               {
               // do your stuff here -- assuming it doesn't block...
               
               synchronized(lock) { quit = shouldQuit; shouldQuit = false; }
               }
           // we're quitting -- do cleanup here if you need to
           }

       protected void halt(boolean pausing)
           {
           synchronized(lock) { shouldQuit = val; }
           }
       };
    </tt></pre>

    <p>Let's say the task also needs to distinguish between being paused and being quit as well.
    Here's some code for this situation:

    <pre><tt>
   AsynchronousSteppable s = new AsynchronousSteppable()
       {
       boolean shouldQuit = false;
       boolean shouldPause = false;
       Object[] lock = new Object[0]; // an array is a unique, serializable object

       protected void run(boolean resuming, boolean restoringFromCheckpoint)
           {
           boolean quit = false;
           boolean pause = false;
           
           if (!resuming)
               {
               // we're starting fresh -- set up here if you have to
               }
           else if (restoringFromCheckpoint)
               {
               // do anything you need when restoring from a checkpoint, like seeking in files
               }
           else
               {
               // we're resuming from a pause -- re-set up here if you have to
               }

           while(!quit && !pause)
               {
               // do your stuff here -- assuming it doesn't block...
               
               synchronized(lock)
                   {
                   quit = shouldQuit;
                   shouldQuit = false;
                   pause = shouldPause;
                   shouldPause = false;
                   }
               }

           if (quit)
               {
               // we're quitting -- do cleanup here if you need to
               }
           else // if (pause)
               {
               // we're pausing -- do cleanup here if you need to
               }
           }

       protected void halt(boolean pausing)
           {
           synchronized(lock) 
               {
               if (pausing) shouldPause = val;
               else shouldQuit = val;
               }
           }
       };
    </tt></pre></div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../serialized-form.html#sim.engine.AsynchronousSteppable">Serialized Form</a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#state">state</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#AsynchronousSteppable--">AsynchronousSteppable</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t6" class="tableTab"><span><a href="javascript:show(32);">Deprecated Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#finalize--">finalize</a></span>()</code>&nbsp;</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#halt-boolean-">halt</a></span>(boolean&nbsp;pausing)</code>
<div class="block">This method should cause the loop created in run(...) to die.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#pause--">pause</a></span>()</code>
<div class="block">Requests that the AsynchronousSteppable shut down its thread (temporarily) and blocks until this occurs.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#resume--">resume</a></span>()</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">use resume(boolean)</span></div>
</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#resume-boolean-">resume</a></span>(boolean&nbsp;restoringFromCheckpoint)</code>
<div class="block">Fires up the AsynchronousSteppable after a pause().</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#run-boolean-">run</a></span>(boolean&nbsp;resuming)</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">override run(resuming, restoringFromCheckpoint) instead.</span></div>
</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#run-boolean-boolean-">run</a></span>(boolean&nbsp;resuming,
   boolean&nbsp;restoringFromCheckpoint)</code>
<div class="block">This method should enter the parallel thread's loop.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#step-sim.engine.SimState-">step</a></span>(<a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a>&nbsp;state)</code>
<div class="block">Fires up the AsynchronousSteppable and registers it with the SimState.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#stop--">stop</a></span>()</code>
<div class="block">Requests that the AsynchronousSteppable shut down its thread, and blocks until this occurs.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../sim/engine/AsynchronousSteppable.html#stopper--">stopper</a></span>()</code>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;
<div class="block"><span class="deprecationComment">Will be deleted in the future.</span></div>
</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="state">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>state</h4>
<pre>protected&nbsp;<a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a> state</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="AsynchronousSteppable--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>AsynchronousSteppable</h4>
<pre>public&nbsp;AsynchronousSteppable()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="run-boolean-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>run</h4>
<pre>protected&nbsp;void&nbsp;run(boolean&nbsp;resuming,
                   boolean&nbsp;restoringFromCheckpoint)</pre>
<div class="block">This method should enter the parallel thread's loop.  If resuming is true, then you may assume
        the parallel steppable is being resumed in the middle of a simulation after being paused (likely to checkpoint),
        as opposed to being started fresh.</div>
</li>
</ul>
<a name="run-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>run</h4>
<pre>protected&nbsp;void&nbsp;run(boolean&nbsp;resuming)</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">override run(resuming, restoringFromCheckpoint) instead.</span></div>
</li>
</ul>
<a name="halt-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>halt</h4>
<pre>protected&nbsp;void&nbsp;halt(boolean&nbsp;pausing)</pre>
<div class="block">This method should cause the loop created in run(...) to die.  If pausing is true, then you may assume
        the parallel steppable is being paused in the middle of a simulation (likely to checkpoint),
        as opposed to being entirely stopped due to the end of the simulation.</div>
</li>
</ul>
<a name="step-sim.engine.SimState-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step</h4>
<pre>public final&nbsp;void&nbsp;step(<a href="../../sim/engine/SimState.html" title="class in sim.engine">SimState</a>&nbsp;state)</pre>
<div class="block">Fires up the AsynchronousSteppable and registers it with the SimState.
        If it's already running, nothing happens.</div>
</li>
</ul>
<a name="stop--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stop</h4>
<pre>public final&nbsp;void&nbsp;stop()</pre>
<div class="block">Requests that the AsynchronousSteppable shut down its thread, and blocks until this occurs. If it's already stopped, nothing happens.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../../sim/engine/Stoppable.html#stop--">stop</a></code>&nbsp;in interface&nbsp;<code><a href="../../sim/engine/Stoppable.html" title="interface in sim.engine">Stoppable</a></code></dd>
</dl>
</li>
</ul>
<a name="pause--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pause</h4>
<pre>public final&nbsp;void&nbsp;pause()</pre>
<div class="block">Requests that the AsynchronousSteppable shut down its thread (temporarily) and blocks until this occurs. If it's already paused or not running, nothing happens.</div>
</li>
</ul>
<a name="resume--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resume</h4>
<pre>public final&nbsp;void&nbsp;resume()</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">use resume(boolean)</span></div>
<div class="block">Fires up the AsynchronousSteppable after a pause().
        If it's already unpaused or not running, nothing happens.</div>
</li>
</ul>
<a name="resume-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resume</h4>
<pre>public final&nbsp;void&nbsp;resume(boolean&nbsp;restoringFromCheckpoint)</pre>
<div class="block">Fires up the AsynchronousSteppable after a pause().
        If it's already unpaused or not running, nothing happens. 
        If 'restoringFromCheckpoint' is TRUE then resume(...)
        is called when MASON is being started up from checkpoint.
        Otherwise it is false.</div>
</li>
</ul>
<a name="finalize--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>finalize</h4>
<pre>protected&nbsp;void&nbsp;finalize()
                 throws java.lang.Throwable</pre>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>finalize</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.Throwable</code></dd>
</dl>
</li>
</ul>
<a name="stopper--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>stopper</h4>
<pre>public final&nbsp;<a href="../../sim/engine/Steppable.html" title="interface in sim.engine">Steppable</a>&nbsp;stopper()</pre>
<div class="block"><span class="deprecatedLabel">Deprecated.</span>&nbsp;<span class="deprecationComment">Will be deleted in the future.</span></div>
<div class="block">Call this method to get a Steppable, which when called, executes top() on the AsynchornousSteppable.
        You can then schedule this Steppable to occur at some point in the future on a schedule.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../sim/engine/MakesSimState.html" title="interface in sim.engine"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?sim/engine/AsynchronousSteppable.html" target="_top">Frames</a></li>
<li><a href="AsynchronousSteppable.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
